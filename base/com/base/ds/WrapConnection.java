package com.base.ds;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.Map;
import java.util.Vector;

import org.apache.log4j.Logger;

import com.base.web.AppConfig;

public class WrapConnection implements Connection {
	private static final Logger log = Logger.getLogger(WrapConnection.class);
	private Connection _con;
	private int numberStatement = 0;
	private Vector<Statement> statementV = new Vector<Statement>();
	private Vector<PreparedStatement> preparedStatementV = new Vector<PreparedStatement>();
	private Vector<CallableStatement> callableStatementV = new Vector<CallableStatement>();
	private long lastTime;

	public long getLastTime() {
		return lastTime;
	}

	public void setLastTime(long lastTime) {
		this.lastTime = lastTime;
	}

	public WrapConnection(Connection con) {
		this._con = con;
	}

	public void clearWarnings() throws SQLException {
		_con.clearWarnings();

	}

	public void close() throws SQLException {
		// _con.close();
		log.info("try to close " + _con);
	}

	public Connection realConnection() {
		return this._con;
	}

	public void commit() throws SQLException {
		_con.commit();

	}

	public Statement createStatement() throws SQLException {
		numberStatement += 1;
		Statement stat = _con.createStatement();
		statementV.add(stat);
		return stat;
	}

	public Statement createStatement(int resultSetType, int resultSetConcurrency)
			throws SQLException {
		numberStatement += 1;
		Statement stat = _con.createStatement(resultSetType,
				resultSetConcurrency);
		statementV.add(stat);
		return stat;
	}

	public Statement createStatement(int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		numberStatement += 1;
		Statement stat = _con.createStatement(resultSetType,
				resultSetConcurrency, resultSetHoldability);
		statementV.add(stat);
		return stat;
	}

	public boolean getAutoCommit() throws SQLException {
		return _con.getAutoCommit();
	}

	public String getCatalog() throws SQLException {
		return _con.getCatalog();
	}

	public int getHoldability() throws SQLException {
		return _con.getHoldability();
	}

	public DatabaseMetaData getMetaData() throws SQLException {
		return _con.getMetaData();
	}

	public int getTransactionIsolation() throws SQLException {
		return _con.getTransactionIsolation();
	}

	public Map<String, Class<?>> getTypeMap() throws SQLException {
		return _con.getTypeMap();
	}

	public SQLWarning getWarnings() throws SQLException {
		return _con.getWarnings();
	}

	public boolean isClosed() throws SQLException {
		return _con.isClosed();
	}

	public boolean isReadOnly() throws SQLException {
		return _con.isReadOnly();
	}

	public String nativeSQL(String sql) throws SQLException {
		return _con.nativeSQL(sql);
	}

	public CallableStatement prepareCall(String sql) throws SQLException {
		numberStatement += 1;
		CallableStatement cstat = _con.prepareCall(sql);
		callableStatementV.add(cstat);
		return cstat;
	}

	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		numberStatement += 1;
		CallableStatement cstat = _con.prepareCall(sql, resultSetType,
				resultSetConcurrency);
		callableStatementV.add(cstat);
		return cstat;
	}

	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		numberStatement += 1;
		CallableStatement cstat = _con.prepareCall(sql, resultSetType,
				resultSetConcurrency, resultSetHoldability);
		callableStatementV.add(cstat);
		return cstat;
	}

	public PreparedStatement prepareStatement(String sql) throws SQLException {
		numberStatement += 1;
		PreparedStatement pstat;
		try {
			pstat = _con.prepareStatement(sql);
		} catch (SQLException ex) {
			log.info(this.hashCode() + " prepareStatement error!");
			throw ex;
		}
		preparedStatementV.add(pstat);
		return pstat;
	}

	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
			throws SQLException {
		numberStatement += 1;
		PreparedStatement pstat = _con.prepareStatement(sql, autoGeneratedKeys);
		preparedStatementV.add(pstat);
		return pstat;
	}

	public PreparedStatement prepareStatement(String sql, int[] columnIndexes)
			throws SQLException {
		numberStatement += 1;
		PreparedStatement pstat = _con.prepareStatement(sql, columnIndexes);
		preparedStatementV.add(pstat);
		return pstat;
	}

	public PreparedStatement prepareStatement(String sql, String[] columnNames)
			throws SQLException {
		numberStatement += 1;
		PreparedStatement pstat = _con.prepareStatement(sql, columnNames);
		preparedStatementV.add(pstat);
		return pstat;
	}

	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		numberStatement += 1;
		PreparedStatement pstat = _con.prepareStatement(sql, resultSetType,
				resultSetConcurrency);
		preparedStatementV.add(pstat);
		return pstat;
	}

	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		numberStatement += 1;
		PreparedStatement pstat = _con.prepareStatement(sql, resultSetType,
				resultSetConcurrency, resultSetHoldability);
		preparedStatementV.add(pstat);
		return pstat;
	}

	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		_con.releaseSavepoint(savepoint);

	}

	public void rollback() throws SQLException {
		_con.rollback();

	}

	public void rollback(Savepoint savepoint) throws SQLException {
		_con.rollback(savepoint);

	}

	public void setAutoCommit(boolean autoCommit) throws SQLException {
		log.debug("try to setAutoCommit>>>" + autoCommit);
	}

	public void realSetAutoCommit(boolean autoCommit) throws SQLException {
		if (!_con.isClosed())
			_con.setAutoCommit(autoCommit);
	}

	public void setCatalog(String catalog) throws SQLException {
		_con.setCatalog(catalog);

	}

	public void setHoldability(int holdability) throws SQLException {
		_con.setHoldability(holdability);

	}

	public void setReadOnly(boolean readOnly) throws SQLException {
		_con.setReadOnly(readOnly);
	}

	public Savepoint setSavepoint() throws SQLException {
		return _con.setSavepoint();
	}

	public Savepoint setSavepoint(String name) throws SQLException {
		return _con.setSavepoint(name);
	}

	public void setTransactionIsolation(int level) throws SQLException {
		_con.setTransactionIsolation(level);

	}

	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
		_con.setTypeMap(map);
	}

	public void realClose() {
		try {
			log.info("realClose connection(ms):"
					+ (System.currentTimeMillis() - this.lastTime));
			if (_con.isClosed())
				return;
			_con.close();
		} catch (SQLException ex) {
			ex.printStackTrace();
		} finally {
			try {
				_con.close();
			} catch (SQLException ex) {
				ex.printStackTrace();
			}
		}

	}

	public boolean validate() {
		try {
			if (this.isClosed() || this.numberStatement >= 200) {
				return false;
			} else if (System.currentTimeMillis() - this.lastTime >= 1000 * 60 * AppConfig
					.getIntPro("lastTime")) {
				return false;
			} else {
				String sql = "select sysdate from dual";
				PreparedStatement stat = this.prepareStatement(sql);
				ResultSet res = stat.executeQuery(sql);
				boolean b = res.next();
				res.close();
				stat.close();
				if (b)
					return true;
				else
					return false;
			}
		} catch (Exception ex) {
			ex.printStackTrace();
			return false;
		}
	}

	public void clearStatement() {
		try {
			for (int i = 0; i < statementV.size(); i++) {
				statementV.get(i).close();
			}
			for (int i = 0; i < preparedStatementV.size(); i++) {
				preparedStatementV.get(i).close();
			}
			for (int i = 0; i < callableStatementV.size(); i++) {
				callableStatementV.get(i).close();
			}
			statementV.clear();
			preparedStatementV.clear();
			callableStatementV.clear();
			numberStatement = 0;
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
}